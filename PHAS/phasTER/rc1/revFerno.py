#!/usr/local/bin/python3

## revFerno: Reverse maps miRferno results to genome co-ordinates
## Updated: version-0.95 10/22/2016
## Property of Meyers Lab at University of Delaware
## Author: kakrana@udel.edu
##  ############

import sys, os, re, time, timeit, csv, glob, string, shutil,operator, argparse
import subprocess, multiprocessing
from multiprocessing import Process, Queue, Pool
from operator import itemgetter

#########################################################################
#### USER SETTINGS ######################################################

res_folder      = "triggers"
# phase           = 24                                        ## Phase length that you are using for double validation 
                                                            ## give corresponding file below

##### DEVELOPER OPTIONS ##########
nthread         = 6                                         ## Need automatic calculation like nProc
nproc           = "Y"                                       ## Used by parallel processing

#### validatePAREby PHAS settings
PAREpval        = 0.25                                      ## Only if PAREresType == 'S' - Cutoff of corrected p-value to
                                                            ## use to filter out non-relevant predictions
pVal            = '5e-07'                                   ## P-value of phased loci to test for
offset          = 1                                         ## 0: No +1/-1 phases scanned 1: In addition to phase +1/-1 sites also checked for trigger


### ARGUMENTS ###########################################################
#########################################################################

parser = argparse.ArgumentParser()
flags = parser.add_argument_group('required arguments') ## Add required arguments to this group and optional to parser

parser.add_argument('-coord',   default='', type=str, help='concatanated file from '\
    'all_coords generated by sPARTA from genic and intergenic target prediction')

parser.add_argument('-predtype',default='P', type=str, help='predicted or PARE validated '\
    'miRNA targets from sPARTA. P: For predicted | D: Degradome validated')

parser.add_argument('-score',   default='6', type=float, help='target score cutoff for '\
    'predicted targets to be used for trigger identification')

flags.add_argument('-predfile',    default='', type=str, help='concatanated file from' \
    'All.targs.parsed files generated by sPARTA from genic and intergenic target prediction')

flags.add_argument('-phas',    default='', type=str, help=' path to collapsed file generated'\
    'by the collapser script from phasTER phased loci prediction analysis')

args = parser.parse_args()

####
if args.coord:
    args.revmap = True
else:
    args.revmap = False
####

####
if args.phas:
    args.valid = True
####

####
if not args.phas:
    if args.predfile:
        print("\n#### File from collapser not provided so only the processing of target prediction "\
            "or validation file will be performed\n")
        time.sleep(2)
    elif not args.predfile:
        print("\n#### Please provide inputs for '-pred' and '-phas' parameters, script will "\
            "exit now")
        sys.exit()
    else:
        pass
else:
    pass
####

### FUNCTIONS ##########################################################

def parsePredicted(predTarF):
    '''
    parses mirferno results for reverse mapping
    '''

    print("\n#### Fn: miRferno Parser ##################")
    print("Reading '%s' file from folder" % predTarF)
    
    predTarL    = []                        ## list of final results or parlist
    acount      = 0                         ## All entries
    bcount      = 0                         ## That passed user provided score cutoff

    fh_in       = open("%s" % predTarF, 'r')    ## PARE VALIDATED results
    predheader  = fh_in.readline()              ## waste header
    aread       = fh_in.readlines()
    
    for res in aread:
        if res.startswith("miRname",0,6):
            # print("Header left in concatanated file")
            pass
        else:
            acount      +=1
            ent    = res.strip('\n').split(',')
            if float(ent[5]) <= args.score:
                predTarL.append(ent)
                bcount+= 1
            else:
                # print("Below user provides score threshold")
                pass
    
    print("Total entries in predicted file:%s | Passed user threshold:%s" % (acount,bcount))
    fh_in.close()

    return predTarL,predheader

def prepareCoordsDict(coordsfile):

    '''
    Prepares global dictionary of coords file for reverse mapping
    '''
    print("\n#### Fn: Coords Dict Maker ################")

    ### GET COORDS #####################################
    fh_in       = open(coordsfile,"r")
    fileRead    = fh_in.readlines()
    coords      = [] ## List to store coords

    for i in fileRead:
        ent     = i.strip("\n").split(",")
        # print("This is read entry",ent)
        coords.append((ent))
    print("Coords read from file:%s entries" % (len(coords)))
    # print("Step 1/4: DONE!!\n\n")

    ####  PREPARE DICTIONARY OF COORDS ########################################
    # print("Step 2/4: Preparing dictionary of coordinates")

    global coord_dict_wat, coord_dict_crick
    coord_dict_wat      = {} ## Dictionary of genes at watson strand, +
    coord_dict_crick    = {}###Dictionary of genes at crick strand, - strand
    shutil.rmtree("./%s" % (res_folder), ignore_errors=True) ## AK Added 
    os.mkdir("./%s" % (res_folder)) ## AK added

    # global nproc
    # nproc ='1' ## Need better handling

    for i in coords:### gene_coords is a list in script, also written out as file of same name
        # print ("This is a coord:",i)
        # strand = i.split(',')[1] for file  ###TEST if reading from file
        strand = i[1]
        if strand == 'c':### if entry in reverse strand
            atuple = (i[0],i[3],i[4],i[5])
            coord_dict_crick[i[2]] = atuple ## Gene name as key and chr_id,start, end and gene type as value
        else:
            atuple = (i[0],i[3],i[4],i[5])
            coord_dict_wat[i[2]] = atuple   ## Gene name as key and chr_id,start, end and gene type as value
            # print (atuple)

        
    print("Strand dictionary made")
    # print("Step 2/4: DONE!!\n\n")

    return None

def revMapper(ent):

    '''
    Reverse maps coordinates for predicted targets. This is required only in case of predicted targets as validated targets are automatically reverse mapped by sPARTA. The genomic coords for the later are directly read from sPARTA output file
    by the PARE reader.  
    '''

    
    ## Create a dictionary from list of coords to be searched later
    ## Gene_coords structure: 1, 'c','AT1G01020', 5928, 8737, protein_coding   
    
    # print (ent)
    mir_name  = ent[0]
    gene_name = ent[1]
    bind_site = ent[2].split('-')

    
    ## Reverse map co-ordinates ##########################################################
    # print ('**No Reverse mapping of Co-ordinates will be performed - Local analysis**')
    if gene_name in coord_dict_wat:
        # print ('Entry: %s in positive strand: %s' % (ent[0:4],coord_dict_wat[gene_name]))
        geno_start  = coord_dict_wat[gene_name][1]  ## Use for reverse mapping of postive genes
        chr_id      = coord_dict_wat[gene_name][0]
        strand      = 'w'                           ## Available in dictionary also coord_dict_crick[gene_name][1]
        gtype       =  coord_dict_wat[gene_name][2] ## Gene type
        
        new_bind_site_start = (int(geno_start)-1)+int(bind_site[0])
        new_bind_site_end   = (int(geno_start)-1)+int(bind_site[1])
        new_bind_site       = '%s-%s' % (new_bind_site_start,new_bind_site_end)

    elif gene_name in coord_dict_crick:
        # print ('Entry: %s in reverse strand: %s' % (ent[0:4],coord_dict_crick[gene_name]))
        geno_end    = coord_dict_crick[gene_name][1] ## Use for reverse mapping of negative genes
        chr_id      = coord_dict_crick[gene_name][0]
        strand      = 'c'                            ## Available in dictionary also coord_dict_crick[gene_name][1]
        gtype       =  coord_dict_crick[gene_name][2]## Gene type

        new_bind_site_end   = (int(geno_end)+1)-int(bind_site[0])###As the sequence was reversed before TF and CL, their binding start and end direction has also changed - Verified-OK
        new_bind_site_start = (int(geno_end)+1)-int(bind_site[1])
        new_bind_site       = '%s-%s' % (new_bind_site_start,new_bind_site_end)
    
    else:
        print("Gene could not be found in 'w' or 'c' strand - please check if correct value to -coords parameter supplied")
        pass


    # print(" Ent: %s %s %s %s | RevMapped: %s %s %s %s" % (mir_name,gene_name,bind_site[0],bind_site[1],str(chr_id),strand,new_bind_site_start,new_bind_site_end))
    rev_mapped_entry = ("%s,%s,%s,%s,%s" % (','.join(ent),str(chr_id),strand,new_bind_site_start,new_bind_site_end))
    
    return rev_mapped_entry

def targetsReader(PAREres,PAREpval):
    '''
    Reads predicted or validated file from sPARTA. In case of degradome validated output from sPARTA, no reversemapping is performed by revFerno but it is checked whether these are from genomic analysis or transcriptome analysis (using 
    featureFile). As, in later local coordinates will be read while in earlier revmapped coordinates in sPARTA output
    will be read. On other hand, in case of predicted sam ething is checked if predicted results are from genomic analysis
    in which reverse mapping will be performed by reverFerno while in case of predicted results from being transcriptome
    analysis reverse mapping is skipped and local coords read.   
    '''

    print("\n#### Fn: Targets Reader ###################")
    
    fh_in   = open(PAREres, 'r')
    header  = fh_in.readline() ## Header
    entries = fh_in.readlines()
    acount  = 0  ## Total entries
    bcount  = 0  ## Filtered entries on targetScore (predicted) or p-value (validated)
    resList = [] ## miRNA,Target,cleavesite,whole entry
    # print ("\n\n\nCreating list of cleave sites\n")
    
    if args.predtype == 'D' and args.revmap == True: ## Degradome validation done using genome, validated file will have revmapped targets 
        for i in entries:
            # print ("\nEnt:",i.strip('\n'))
            acount      += 1  ## Total entries
            ent_splt    = i.split(',')
            # print("\nThis is target entry p-val:",ent_splt[13])
            if float(ent_splt[13])  <= PAREpval:
                cleaveSite          = int(ent_splt[17])
                #print(cleaveSite)
                mirName = ent_splt[0]
                tarName = ent_splt[1]
                chrid   = ent_splt[15].replace("Chromosome","").replace("chromosome","").replace("Chr","").replace("chr","")
                strand  = ent_splt[16]
                resList.append((mirName,tarName,cleaveSite,chrid,strand,i.strip('\n')))
                # print("\nList values for this entry",mirName,tarName,cleaveSite,chrid,strand,i.strip('\n'))
                bcount += 1


    elif args.predtype == 'D' and args.revmap == False: ## Degradome validation done but using transcripts i.e. feature file option. No reversemapping performed and columns will in validated output would be different
        for i in entries:
            # print ("\nEnt:",i.strip('\n'))
            acount      += 1  ## Total entries
            ent_splt    = i.split(',')
            #print("\nThis is target entry",ent_splt[13])
            if float(ent_splt[14]) <= PAREpval:
                cleaveSite = int(ent_splt[8])
                #print(cleaveSite)
                tarName = ent_splt[1]
                mirName = ent_splt[0]
                chrid   = ent_splt[1] ## In local mode there is no chr_id, only transcripts
                strand  = 'None'
                resList.append((mirName,tarName,cleaveSite,chrid,strand,i.strip('\n')))
                # print(mirName,tarName,cleaveSite)
                bcount += 0

    elif args.predtype == 'P' and args.revmap == True: ## miRferno predicted and revmapped above
        for i in entries:
            # print ("\nEnt:",i.strip('\n'))
            acount += 1  ## Total entries
            ent_splt    = i.strip('\n').split(',')
            chrid       = ent_splt[8].replace("Chromosome","").replace("chromosome","").replace("Chr","").replace("chr","") ## In local mode there is no chr_id, only transcripts
            strand      = ent_splt[9]
            # print("\nThis is target entry",ent_splt)
            if float(ent_splt[5]) <= args.score:
                # print("pass")
                bindStart   = ent_splt[10]
                bindEnd     = ent_splt[11]
                if strand == "c":
                    ## This is to accomodate 13th position validation observed for 'c' strand
                    cleaveSite3 = int(bindEnd)-12+1 ## 12th pos +1  - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct ## Added after observing that 2275 cleaves a major portion at 13th pos
                    cleaveSite4 = int(bindEnd)-13+1 ## 13th pos +1 - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                    cleaveSite  = (cleaveSite3,cleaveSite4)
                else:
                    ## Watson strand
                    cleaveSite1 = int(bindEnd)-10+1 ## 10th pos +1  - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                    cleaveSite2 = int(bindEnd)-11+1 ## 11th pos +1 - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                    cleaveSite  = (cleaveSite1,cleaveSite2)
                # print(cleaveSite)
                mirName     = ent_splt[0]
                tarName     = ent_splt[1]
                resList.append((mirName,tarName,cleaveSite,chrid,strand,i.strip('\n')))
                # print("List values for this entry:",mirName,tarName,cleaveSite,chrid)
                bcount += 1

    elif args.predtype == 'P' and args.revmap == False: ## miRferno was run using feature file, no reversmapping done in revFerno
        for i in entries:
            # print ("\nEnt:",i.strip('\n'))
            acount += 1  ## Total entries
            ent_splt = i.strip('\n').split(',')
            # print("\nThis is target entry",ent_splt)
            if float(ent_splt[5]) <= args.score:
                bindStart,bindEnd = ent_splt[2].split("-")
                cleaveSite1 = int(bindEnd)-10+1 ## 10th pos +1  - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                cleaveSite2 = int(bindEnd)-11+1 ## 11th pos +1 - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                # cleaveSite3 = int(bindEnd)-12+1 ## 12th pos +1  - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct ## Added after observing that 2275 cleaves a major portion at 13th pos
                # cleaveSite4 = int(bindEnd)-13+1 ## 13th pos +1 - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                cleaveSite  = (cleaveSite1,cleaveSite2)
                # print(cleaveSite)
                mirName     = ent_splt[0]
                tarName     = ent_splt[1]
                chrid       = ent_splt[1] ## In local mode there is no chr_id, only transcripts
                strand      = 'None'
                resList.append((mirName,tarName,cleaveSite,chrid,strand,i.strip('\n')))
                # print("List values for this entry",mirName,tarName,cleaveSite,chrid,i.strip('\n'))
                bcount += 1
        
    else:
        pass

    print("Input file:%s" % (PAREres))
    print("File entries:%s | Passed p-val/score:%s | List length:%s" % (acount,bcount,len(resList)))
    
    return resList,header

def PHASreader(PHASres):
    ''' Reads the phased result file
    and creates a dictionary of -5/+7 phased locations as value
    '''
    print("\n#### Fn: PHAS Reader ######################")

    # print(PHASres.rsplit("PHAS")[0][-2:])
    phase   = int(PHASres.rsplit("PHAS")[0][-2:])
    fh_in   = open(PHASres,'r')
    header  = fh_in.readline()
    entries = fh_in.readlines()

    PHASdict_h = {} ## From Head i.e. 5' of PHAS Loci - for head scan
    PHASdict_t = {} ## From Tail i.e. 3' of PHAS Loci - for tail scan
    PHASdict_b = {} ## From head and Tail both  i.e.5' and 3' of PHAS Loci - for precursor scan - Not used
    
    ### Create PHAS index ###########################
    print ("Creating dictionary of phased loci")
    if args.predtype == 'D' or args.predtype == 'P':
        if phase == 21:
            phaseList = [-105,-84,-63,-42,-21,0,21,42,63,84,105,126,147]
        elif phase == 24:
            phaseList = [-120,-96,-72,-48,-24,0,24,48,72,96,120,144,168]
        elif phase == 22:
            phaseList = [-110,-88,-66,-44,-22,0,22,44,66,88,110,132,154]
        else:
            print('What the phase for phased loci - Please specify correctly')
            sys.exit()


    ### Parse PHAS results ##########################
    for i in entries:
        if i.strip(): ## Remove an empty line from end file
            # print(i.strip('\n'))
            aname,apval,achr,astart,aend,trash,alib = i.strip('\n').split('\t')
           
            if args.revmap == False: ## No reverse mapping means prediction done on transcripts or feature file
                akey ='%s-%s-%s' % (achr.strip(),astart,aend) ## Since its local analysis, transcrpt name would be chr_id - Modfied in v1.14 by removing this part ".split("|")[0]""
            else:
                akey ='%s-%s-%s' % (achr.strip().replace("Chr","").replace("chr",""),astart,aend)
            
            aval_h = [sum(i) for i in zip([int(astart)]*11,phaseList)]
            aval_t = [sum(i) for i in zip([int(aend)]*11,phaseList)]
            # print ("-Key:%s | 5' value: %s | 3' value: %s\n" % (akey,aval_h,aval_t))
            PHASdict_h[akey] = aval_h
            PHASdict_t[akey] = aval_t


            #fh_out.write('%s\t%s\t%s\t%s\t%s\tNONE\tNONE\n' % (phase,pval,chromo.strip(),start,end))##Chromosome has space before it which later gives error while key matching
            #fh_out.write('%s\t%s\n' % (str(akey),str(aval).strip('[]')))

    print("Head dictionary made with entries:%s" % (len(PHASdict_h)))
    print("Tail dictionary made with entries:%s" % (len(PHASdict_t)))

    #### Sanity Check ############################### 
    if len(PHASdict_t) == 0 and len(PHASdict_h) == 0:
        ## Warn user that something is wrong
        print("Head and tail dictionaries are empty - Please check 'pVal' input is correct or troubleshoot")
        print("Script will exit now")
        sys.exit()
    else:
        pass

    # sys.exit()
    fh_in.close()

    return PHASdict_h,PHASdict_t,phase

def validatePHAS(ent):
    '''
    This function takes one miRNA interation (predicted or validated) and finds matching PHAS
    '''
    
    ## For every interaction 
    #########################
    # print ("\nmiRNA entry being checked as trigger#####################################",ent)
    mirName     = ent[0]
    tarName     = ent[1]
    chrid       = ent[3]
    strand      = ent[4] ## In case of predicted targets, Inferred from intergenic location using genome DB
    matEnt      = "none" ## Intialize empty entry
    
    if args.predtype == 'P':
        cleaveSite1,cleaveSite2 = ent[2] ## Predicted 10th and 11th as cleave site
        # print("\n-Scanning phased loci for these cleave sites:",mirName,tarName,cleaveSite1,cleaveSite2,chrid,strand)
    else:
        cleaveSite = int(ent[2])    ## PARE supported cleave site
        # print("\n-Scanning phased loci for this cleave site:",mirName,tarName,cleaveSite,chrid,strand)
    
    if args.revmap  == True:           ## targets coordinates match to genome DB i.e. server target analysis was done
        tarStrand   = strand  ## Strand comes from revmapped files
    elif args.revmap == False:
        tarStrand   = "w"
    else:
        print("Don't know whoch mode it is - Please check 'targetStrand'")
        sys.exit()

    
    ## Dictionary and value for strand offset
    #########################################
    if args.revmap == True and tarStrand == 'c':                ## Select dict for head or tail scan
        PHASdict        = PHASdict_t    ## Tail scan will be performed
        strandOffVal    = -2            ## Value used for strandOffset list computations i.e. PHAS coordinates correspond to 'w' strand
        # print("-miRNA interaction on 'c' strand - tail scan underway")
        # print("-This is the tail coordinates",PHASdict_t)

    elif args.revmap == True and tarStrand == 'w':              ## Do nothing to cleave site and switch to PHAS dict for tail scan
        PHASdict        = PHASdict_h    ## Head scan will be performed
        strandOffVal    = +2            ## Value used for strandOffset list computations i.e. PHAS coordinates correspond to 'c' strand
        # print("-miRNA interaction on 'w' strand - head scan underway")
        # print("-This is the head coordinates",PHASdict_h)
    elif args.revmap == False:
        PHASdict        = PHASdict_h    ## Head scan will be performed
        strandOffVal    = +2            ## Value used for strandOffset list computations i.e. PHAS coordinates correspond to 'c' strand
        # print("-miRNA interaction on 'w' strand - head scan underway")

    else:
        print("-Strand info is non-sense:%s" % (tarStrand))
        sys.exit()


    ## Perform validation
    ############################################
    if args.predtype == 'D':
        ## PHAS LOCI MATCH -  Was not checking for cleave site in exact chromosome - Thats why you got shit load of results where these are scaffolds
        for akey in PHASdict.keys():
            aval = PHASdict[akey]
            # print ('This is the key:', akey, aval)
            if cleaveSite in aval:
                    if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                        print('-Match - miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                        matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite)+1-6)))
                        # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file
                    else:
                        # print ('Cleave site matched phase index but chromosome was different')
                        pass           

            else:
                ## Cleave site doesn't matches as is with phase site, try after factoring dicer- and strand- offsets
                if offset == 1:
                    aval1 = [x+1 for x in aval] ## Dicer Offset - OK
                    aval2 = [x-1 for x in aval] ## Dicer Offset - OK
                    aval3 = [x+strandOffVal for x in aval] ## Strand Offset

                    if cleaveSite in aval1:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('\n- Match - miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval1.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite)+1-6)))
                            # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval1.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file
                    elif cleaveSite in aval2:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('\n-Match - miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval2.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt  = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite)+1-6)))
                            # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval2.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file

                    elif cleaveSite in aval3:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('\n-Match - miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval3.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt  = ('%s,%s,%s,so' % (ent[5],akey,(aval3.index(cleaveSite)+1-6)))
                    else:
                        # print ('Cleave site matched phase index but chromosme was different')  
                        pass

                else:
                    print("-Offset checking is OFF")
                    pass

    elif args.predtype == 'P': ## miRFerno results with two possible cleave sites both needs to be checked
        
        for akey in PHASdict.keys():
            aval = PHASdict[akey]
            # print ('This is the key:', akey, aval)
            if cleaveSite1 in aval:
                if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                    print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                    matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite1)+1-6)))

            elif cleaveSite2 in aval:
                if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                    print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                    matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite2)+1-6)))

            
            else: ## Cleave site doesnt matches with phase site, try (dicer cut) offsets maybe
                if offset == 1:
                    aval1 = [x+1 for x in aval] ## Dicer Offset
                    aval2 = [x-1 for x in aval] ## Dicer Offset
                    aval3 = [x+strandOffVal for x in aval] ## Strand Offset
                    
                    ### THIS LOOP CAN BE REDUCED by using a list of cleave sites rather than adding loop everytime - It's a joke
                    if cleaveSite1 in aval1:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval1.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt  = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite1)+1-6)))

                    elif cleaveSite2 in aval1:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval1.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite2)+1-6)))
                    
                    elif cleaveSite1 in aval2:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval2.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite1)+1-6)))

                    elif cleaveSite2 in aval2:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval2.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite2)+1-6)))

                   
                    elif cleaveSite1 in aval3:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval3.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,so' % (ent[5],akey,(aval3.index(cleaveSite1)+1-6)))

                    elif cleaveSite2 in aval3:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval3.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,so' % (ent[5],akey,(aval3.index(cleaveSite2)+1-6)))

                    else:
                        # print ('Cleave site matched phase index but chromosme was different')  
                        pass
    
    else:
        print("Input correct PARE result type in user settings - Script will exit now")
        sys.exit()


    # ##### LOCAL MODE ###########################################
    # ############################################################
    
    # elif mode == 1: ## Local analysis - Targets are transcripts and no chr_id or strand is required from server

    #     #### PARE validated cleave sites #######################
    #     #######################################################
    #     if PAREresType == 'S' or PAREresType == 'C':
    #         for akey in PHASdict.keys():
    #             aval = PHASdict[akey]
    #             #print ('This is the key:', akey, aval)
    #             if cleaveSite in aval:
    #                     if akey.split('-')[0] == chrid: ## i.e. clevage site is on same transcript
    #                         print('\nmiRNA:%s | Target:%s |CleaveSite:%s | PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,akey,aval,(aval.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                         matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite)+1-6)))
    #                         # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval.index(cleaveSite)+1-6)))

    #                     else:
    #                         print ('Cleave site matched phase index but chromosme was different')            
    #             else:
    #                 ## Cleave site doesnt matches with phase site, try (dicer cut) offsets maybe
    #                 if offset == 1:
    #                     aval1 = [x+1 for x in aval]
    #                     aval2 = [x-1 for x in aval]
    #                     if cleaveSite in aval1:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval1.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite)+1-6)))
    #                             # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval1.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file

    #                     elif cleaveSite in aval2:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval2.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite)+1-6)))
    #                             # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval2.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file

    #                     else:
    #                         # print ('Cleave site matched phase index but chromosme was different')  
    #                         pass

    #     #### Cleave sites from miRferno #####################
    #     #####################################################
    #     elif PAREresType == 'T':
    #         for akey in PHASdict.keys():
    #             aval = PHASdict[akey]
    #             print ('This is the key:', akey, aval)
    #             # print(cleaveSite1,cleaveSite2)
    #             if cleaveSite1 in aval:
    #                     if akey.split('-')[0] == chrid: ## i.e. cleavage site is on same transcript
    #                         print('\nmiRNA:%s | Target:%s |CleaveSite:%s | PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,akey,aval,(aval.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                         matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite1)+1-6)))
    #             elif cleaveSite2 in aval:
    #                     if akey.split('-')[0] == chrid: ## i.e. clevage site is on same transcript
    #                         print('\nmiRNA:%s | Target:%s |CleaveSite:%s | PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,akey,aval,(aval.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                         matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite2)+1-6)))
     
    #             else:
    #                 ## Cleave site doesnt matches with phase site, try (dicer cut) offsets maybe
    #                 if offset == 1:
    #                     aval1 = [x+1 for x in aval]
    #                     aval2 = [x-1 for x in aval]
    #                     if cleaveSite1 in aval1:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval1.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite1)+1-6)))
    #                     elif cleaveSite2 in aval1:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval1.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite2)+1-6)))

    #                     elif cleaveSite1 in aval2:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval2.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite1)+1-6)))
    #                     elif cleaveSite2 in aval2:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval2.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite2)+1-6)))

    #                     else:
    #                         # print ('No match found even with dicer offsets')  
    #                         pass
        # else:
        #     print("Input correct PARE result type in user settings")
        #     pass

    return matEnt

def PP(module,alist):
    print('***********Parallel instance of %s is being executed*********' % (module))
    
    start = time.time()
    ##PP is being used for Bowtie mappings - This will avoid overflooding of processes to server
    nprocPP = round((nproc/int(nthread))+1) ## 1 added so as to avoid 0 processor being allocated in serial mode
    print('\nnprocPP:%s\n' % (nprocPP))
    npool = Pool(int(nprocPP))
    npool.map(module, alist)

def PPmultiple(module,alist1,alist2):
    start = time.time()
    npool = Pool(int(nproc))
    npool.map(lambda args: module(*args), alist2)

def PPResults(module,alist):
    npool = Pool(int(nproc))    
    res = npool.map_async(module, alist)
    if(res.get() == []):
        print("YEP!")
    results = (res.get())
    npool.close()           ### Added by Reza to close hanging 
    return results

def revmapWriter(revmapL,afile,predheader):
    '''
    writes results from reverse mapping
    '''
    # print("\n#### Fn: revMap Writer ################")
    revmapF     = './%s/%s_revmapped.csv' % (res_folder,afile)
    fh_out      = open(revmapF, 'w')
    fh_out.write('%s,Chr,Strand,GenomicBindStart,GenomicBindEnd\n' % (predheader.strip('\n')))
    for i in revmapL: ## Write Results from list to file
        if i != 'E13-3-13':##Filter for error 13-13-13 that is small window abundance = 0 and ratio calculation error
            fh_out.write('%s\n' % (i))
        else:
            print (i)
            pass

    fh_out.close()

    return revmapF

def revfernoWriter(validPHAS,resList,PHASdict_h):

    '''
    Writes validated PHAS results 
    '''
    print("\n#### Fn: revFerno Writer ################")
    
    ## Write results
    validphasF  = './%s/%s_trigger.csv' % (res_folder,args.predfile)
    fh_out      = open(validphasF,'w')
    fh_out.write('%s,PHASLoci,PHASindex,matFlag\n' % (header.strip('\n')))
    
    acount = 0 ## Matched count
    for i in validPHAS:
        if i != "none":
            fh_out.write("%s\n" % (i))
            acount +=1
    fh_out.close()

    print("Total entries in triggers list:%s | Entries in PHAS dict %s" % (len(resList),len(PHASdict_h)))
    print("Matched (miR redundant):%s" % (acount))

    return validphasF

### MAIN #######################
def main():

    ### Global variables
    global PHASdict_h
    global PHASdict_t
    global PHASdict_b
    global header

    ### Prepare for analysis
    if os.path.isdir("./%s" % (res_folder)):
        print("\nWARNING: 'triggers' results exist from earlier run, these will be deleted")
    else:
        pass

    shutil.rmtree("%s" % (res_folder),ignore_errors=True)
    os.mkdir("%s" % (res_folder))

    ### Reverse mapping
    ################### 
    if args.predtype == "P" and args.revmap == True:
        
        ### GET COORDS ####
        prepareCoordsDict(args.coord)
        predTarL,predheader = parsePredicted(args.predfile)        
        
        ### REVERSE MAP ####
        print("\n#### Fn: Reverse Mapper ####################") 
        
        #### TEST - Serial Mode #######
        # print('\n***Entering RevMapCoord- Serial***\n')
        # revmapL = []
        # for i in predTarL:
        #     # print("\nEntry for reverse mapping:%s" % (i))
        #     z = RevMapCoord(i)
        #     revmapL.append(z)
        
        ### Default - parallelized mode - uncomment serial mode above after testing
        print('***Entering RevMapCoord- parallel***')
        revmapL = PPResults(revMapper, predTarL) ## Results are in form of list
        print('Reverse mapping complete for:%s' % (args.predfile))
        time.sleep(1)

        revmapF         = revmapWriter(revmapL,args.predfile,predheader)
        resList,header  = targetsReader(revmapF,PAREpval)

    else:
        resList,header = targetsReader(args.predfile,PAREpval)

    #### Predict triggers
    #####################
    if args.phas:
        PHASdict_h,PHASdict_t,phase = PHASreader(args.phas)
        
        print("\n#### Fn: Trigger Predictor #################")
        #### TEST - Serial Mode #######
        # validPHAS = [] ## Store results
        # for i in resList:
        #     matEnt = validatePHAS(i)
        #     validPHAS.append(matEnt)

        ### DEFAULT - parallelized mode - uncomment serial mode above after testing ##
        validPHAS = PPResults(validatePHAS,resList) ## Results are in form of list
        validphasF = revfernoWriter(validPHAS,resList,PHASdict_h)

    else:
        pass

if __name__ == '__main__':

    if nproc == 'Y':
        nproc = int(multiprocessing.cpu_count()*0.80)
    else:
        nproc == int(nproc)
    start = time.time()
    main()
    end = time.time()
    print('\nThe run has completed sucessfully')
    print('Complete run time is %ss\n' % (round(end-start,2)))
    sys.exit()


## v01
## Written to revmap internal mirFErno predicted targets

## v01 -> v02 [stable] [Nov-4-2015]
## Added compatibility to sPARTAv1.16 and above
## Modifed user input - now afile is provided for reverse mapping instead of lookup in folder
## Improved user experienece stuff, cleaned up the script

## v09 -> v095
## Renamed args.pred to args.predfile
## Added 'required' category to args.parse


