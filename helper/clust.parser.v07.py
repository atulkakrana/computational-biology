#!/usr/local/bin/python3

### Apr-7-16 - This script works on clusters file generated by cd-hit. Script parses these results in mode 0 and in mode 1 tests significance of observing these by random chance

import os,sys,operator,random,subprocess,time,datetime
import mysql.connector as sql
import subprocess, multiprocessing
import itertools as it
from multiprocessing import Process, Queue, Pool

mode            = 0             ## Mode 0 - Parse just the cd-hit file | Mode 1: generate random samples from parsed cd-hit file
clustFile       = "temp.clstr"  ## Input cluster file, this is the cd-hit results you want to parse, or test significance through random sampling - It must be generated using two or more psecies with a prefix in their names in fasta file i.e. LA_*, ZM_* or OS_*  - file La.Zm.24Phas.finalcands.collapse.clstr

## P-VALUE COMPUTE SETTINGS - Required in Mode-1
featureFile     = "La.Zm.24Phas.finalcands.collapse.txt" ## file - La.Zm.24Phas.finalcands.collapse.txt
testsuffix      = "LA"              ## Suffix provided to test species, this is used in mode-2 only to fetch their sequences
testfastaFile   = "La.24Phas.finalcands.collapse.fa" ## Fasta file of test species, so that conserved seqeunces can be tested for significance
cntsuffix   = "ZM"              ## This is required to add to random seqeunces, so that clusters with different suffix could be found
cntsource       = 'F'               ## Random coords to be fetched from served or from FASTA file - "S" - Server, "F" - FASTA

## SAMPLER SETTINGS - Required in Mode-1
niter           = 500
nsamples        = 280          ## This should be equal to number of seqeunces used for control species i.e. number of Maize PHAS that were checked for conservation with Lilium. 
coordsFile      = "Trinity.summ.txt"
cntfastaFile    = "Zm.Trinity.fa"   ## This must have same suffix as used for clustering i.e. species suffix used in clustering input

### COORDS2FASTA SETTINGS - Required in Mode-1
server          = "tarkan.ddpsc.org"
genomedb        = 'MAIZE_AGPv2_genome'     ## Genome DB to use for extraction

nproc = '50'

##################################################
def sigclust(clustD):
    '''
    This identifies clusters with sequeces from different species
    '''

    sigclustD = {} ## Dictionary to hold results for clusters with seqeunces from more then one species
    ### Identify which clusters have more then 1 species in suffix set
    for akey in clustD.keys():
        # print("\nProcessing cluster:%s" % (akey))
        clustseqL,suffS = clustD[akey]
        # print("Cluster:",clustseqL)

        if len(suffS) > 1:
            # print("Multiple species cluster",suffS)

            ## Get first entry for each species suffix
            tempres = [] ## Store cluster speciifc entries from multiple libraries 
            for asuff in suffS:
                # print("Scanning suffix:%s" % (asuff))
                xcount = 0
                
                for i in clustseqL:
                    bid,blen,bsuff,bname,bperc = i
                    if asuff == bsuff and xcount == 0:
                        xcount+=1
                        # print("Got entry",i)
                        tempres.append(i)
                        continue
                    else:
                        pass

            ## Seqeunces fro all species fetched, now add to final dictionary of results
            sigclustD[akey] = tempres
            # print("Species in cluster:%s | seqeunces fetched:%s" % (len(suffS),len(tempres)))

        else:
            # print("Cluster have seqeunces from just one species")
            pass

    return sigclustD

def pvalcompute(sigclustD,coordsFile):
    '''
    Generates random population of seqeunces for size of species other then
    '''

    fastaL,fastaD   = fastaReader(testfastaFile)    ## Read combined or test species fasta file, this should have seqeunces of test species
    global coordsD
    coordsD         = coordsparser(coordsFile)      ## Read genomic oords for random sampling

    if cntsource =="S":
        con = ConnectToDB(server)           ## Connection to fetch fasta seqeunces from server
    elif cntsource == "F":
        cntfastaL,cntfastaD   = fastaReader(cntfastaFile) ## If random samples were from FASTA file instead of genome
    else:
        print("Please select correct control source mode - 'S' or 'F'")
        sys.exit()


    ### Master loop starts here, for every significant result
    #########################################################
    pvalD   = {} ## This will hold p-values for every match of PHAS you found (clustFile) for test-species i.e. Lilium; against random samlping from control species.

    sigrescount = len(sigclustD.keys())
    runcount    = 0
    for ares in sigclustD.keys():
        # print("********* start - All Keys:",sigclustD.keys())
        runcount +=1 
        print("\n#### Computing p-val for %s/%s cluster:%s ####################\n" % (runcount,sigrescount,ares))
        sigseqs = sigclustD[ares]

        ## Get featuresD for random sampling and seqeuence of the test species
        featuresD,testL = prepare(sigseqs,ares)
        trashid,testname,testthres = testL ## TestL - clusterid, test seqname and cutoff for testing
        testseq         = fastaD[testname][0] ## seq, len 
        ## Get random coords and fetch fasta from server
        randcoordsD = sampler(coordsD,featuresD,niter,nsamples)
        # print("iter in random coords dict:%s" % (len(randcoordsD)))

        ## For each iteration ###########
        ################################
        acount      = 0 ## Count of itnerations
        randcoordsL = randcoordsD[ares]
        iterres     = [] ## List with best match threshold from every itneration, length of list == niter
        for iterL in randcoordsL:
            acount+=1
            print("####Cluster:%s | Iter:%s###############################" % (ares,acount))
            iterL_s     = sorted(iterL, key=operator.itemgetter(0)) ## To speed up
            
            ## Fetch seqeunces for random samples either from server or from FASTA file
            if cntsource    == 'S':
                tempcoords  = randcoordsWriter(ares,iterL_s)
                tempfasta = Coords2FASTA(con,tempcoords,genomedb,0,0)
            elif cntsource  =='F':
                ## Fetch coords from fasta file like in case of trinity assembly
                tempfasta = coords2fasta2(cntfastaD,iterL_s)
            else:
                print("Please select correct control source mode - 'S' or 'F'")
                sys.exit()


            ## Add test seq to random fasta
            with open(tempfasta,'a') as fh_out:
                fh_out.write(">%s\n%s\n" % (testname,testseq))
            
            ## Run cd-hit, parse results
            retcode = subprocess.call(['./cd-hit-auto.sh'])
            if retcode == 0:## The bowtie mapping exit with status 0, all is well
                # print("\ncd-hit finished successfully" )
                pass
            else:
                print('Something wrong happened while running cd-hit for sequence: %s - - Debug for reason')
                sys.exit()

            randclustD      = parseclust("temp.clstr")
            randsigclustD   = sigclust(randclustD)
            print("Sig. found:%s" % (len(randsigclustD)))

            # Get best percentage match for test seqeunce from random results, if no siginificant match then best random perc = 0.00
            if not randsigclustD.keys():
                bestrandperc = 0.00
            else:
                tempperc = []
                for akey in randsigclustD.keys():
                    avalues = randsigclustD[akey]
                    for i in avalues: ## seqeunces for different species and their cutoff, avoid representative cutoff of 100% here
                        aid,alen,asuff,aname,aperc = i
                        tempperc.append(float(aperc))
                bestrandperc_s     = sorted(tempperc, key=lambda x: float(x))
                bestrandperc       = bestrandperc_s[0] ## Take the second pest perc because representatitive sequene has 100% assigned in this script, we want to avoid it, and take best match with other species

            iterres.append(bestrandperc) ## Holds best match fround in random seqeunces with test seqeunces, for all itnerations

        # compute p-value
        randwins = 0        ## Count of matches found in random sampling that are better then testthres
        for randperc in iterres:
            if randperc > testthres: ## randperc cutoff must be lower then test thres
                randwins+=1 
            else:
                pass

        testpval = round(randwins/niter,6) 
        print("RESULTS - clust%s | testthres:%s | random wins:%s | p-val:%s" % (ares,testthres,randwins,testpval))
        pvalD[ares] = (testpval,testname)
    
    resfile = writer2(sigclustD,pvalD)

    return resfile

def coords2fasta2(cntfastaD,coords):

    '''
    This function samples from a fasta file directly, coords could be generated with clean fasta summaries
    '''

    ### Read the coords and prepare dict

    outfile   = "temp.coords.fa"
    fh_out    = open(outfile,'w')

    for acoord in coords:
        # print(acoord)
        arandchr,randstart,randend,randstrand = acoord

        transfasta,translen  = cntfastaD[arandchr]
        randseq     = transfasta[randstart:randend+1] ## to include last nucleotide
        # print ('This is chr_id:%s | Start:%s | End:%s | Length of sequence: %s bp\n' % (arandchr,randstart,randend,(randend+1)-randstart))

        # print(">%s\n%s\n" % (arandchr,randseq))
        fh_out.write(">%s\n%s\n" % (arandchr,randseq))
        # sys.exit()

    fh_out.close()

    return outfile

def prepare(sigseqs,ares):
    '''
    given results i.e. from significant cluster, this returns len for random sampling based on control or matching seqeunces; 
    and the name of test seq
    '''

    featuresD   = {} ## This used as input for random sampling to provide length required
    testL       = [] ## Stores cluster id, test seq name and pid
    templen     = [] ## Recond length of seqeunces of othe species
    tempperc    = [] ## Store percentages because any seq could be representatve with 100% value, we need a cutoff other then representative
    for i in sigseqs:
        print(i)
        aid,alen,asuff,aname,aperc = i
        tempperc.append(aperc)

        if asuff == testsuffix:
            ## Get seqeunce name
            bname = aname.split("...")[0]
            print("Test Seq:",bname)
            testL.append(ares) ## ares is the cluster id
            testL.append(bname)

        elif asuff != testsuffix:
            # print(alen)
            templen.append(int(alen))

        else:
            print("Wrong turn - Investigate E1")
            sys.exit()

        ## Get longest length
    maxlen  = max(templen)
    minperc = min(tempperc) ## Because max is 100%, this is OK for two species and three species, but median would be best for more species 
    featuresD[ares] = ("chr99",maxlen)
    testL.append(minperc)
    # sys.exit()

    # print("############",testL)

    return featuresD,testL

def parseclust(clustFile):
    '''parses the cluster file, and stores into a dictionary with cluster id as key and list of other entries as values'''

    print("\nFn:parseclust")

    fh_in = open(clustFile,'r')
    fileRead = fh_in.read().split('>Cluster')
    fh_in.close()
    # print(fileRead)

    clustD = {} ## Dict to hold results
    acount = 0 ## Count of cluters in the file
    for aclust in fileRead[1:]: ## First one is empty due to split
        # print("\n+Cluster:\n",aclust)
        entries = aclust.split("\n")
        # print("-Entries",entries)
        clustid = entries[0].strip()
        acount+=1

        ### Get the seqeunces in clusters
        # print("Entries:")
        clustseqL = [] ## Temporary list to store the seqeunces
        suffS     = set()
        for i in entries[1:]: ## First one is the id, and rest are entries that needs to be split on tab
            if i:
                ent = i.split("\t")
                # print(ent)
                aid     = ent[0]
                atemp   = ent[1].split(",")
                alen    = atemp[0].replace("aa","")
                aname   = atemp[1].strip().replace(">","")
                asuff   = aname.split("_")[0]
                suffS.add(asuff)

                if aname[-1] == "*":
                    # print("-Representative seqeunces:%s" % (aname))
                    aperc = float(100.00)
                else:
                    aperc = float(aname.rpartition("/")[-1].replace("%",""))

                # print("-%s\t%s\t%s\t%s\t%s" % (aid,alen,asuff,aname,aperc))
                clustseqL.append((aid,alen,asuff,aname,aperc))

            ## Sort the cluster sequences on perecentages
        clustseqL_s = sorted(clustseqL, key=operator.itemgetter(4),reverse=True)
        # print(clustseqL_s)


        clustD[clustid] = (clustseqL_s,suffS) ## All the seqeunces from cluster and suffix for species in cluster
    
    print("\nClusters in file:%s | clusters in dict:%s" % (acount,len(clustD)))
    print("Fn:parseclust - Exiting\n")
    return clustD

def writer(sigclustD):
    '''
    writes results - comaptaible with as many as species
    '''
    outfile = "cd-hit.parsed.txt"
    fh_out = open(outfile,'w')

    for akey in sigclustD.keys():
        ares    = sigclustD[akey]
        # print("Results",ares)
        lenL    = [str(x[1]) for x in ares]
        seqL    = [str(y[3]) for y in ares]
        percL   = [str(z[4]) for z in ares]

        combres = ['\t'.join(pair) for pair in zip(seqL,percL,lenL)]
        # print("Comb Results:",combres)
        fh_out.write("%s\t%s\n" % (str(akey),"\t".join(combres)))

        # fh_out.write("%s\t%s\t%s\t%s\n" % (str(akey),"\t".join(seqL),"\t".join(percL),"\t".join(lenL)))

    fh_out.close()
    return outfile

def sampler(coordsD,featuresD,niter,nsamples):
    '''
    Generates a dict of randomly picked regions from specific chromosome equal to sample size, and repeat the same for number of itnerations
    '''
    print("\nFn: sampler #########")
    strandL     = ['+','-'] ## Used later to select strand
    randcoordsD = {} ## Dictionary that holds coords (equaling sample size) x nitenerations i.e.[(List from itneration1),(itneration2)...]

    for afeature in featuresD.keys():
        print("+Random sampling for %s" % (afeature))
        reqchr,reqlen = featuresD[afeature] ## Chromosome-specific sampling is not required in case of asparagus, becaus ethese have scaffolds
        niterL          = list(range(1,niter+1)) ## A list of numbers to just implement parallel processing
        rawinputs       = [] ## List of inputs for paralleization
        for i in niterL:
            rawinputs.append((i,reqlen,strandL))
        print("raw inputs ready for %s iters" % (len(rawinputs)))

        featurecoords   = PPResults(randompicker,rawinputs) ## Store random coords from all itnerations

        # featurecoords = [] ### Store random coords from all itnerations
        # chrL = coordsD.keys()
        # for aniter in range(niter):
        #     print("-iter-%s" % aniter)
        #     ### Draw random chromosomes - double the same size, just to keep some extra
        #     iterL       = [] ## Random coords for itneration 
            
        #     for i in range(nsamples*4):
        #         ### Now pick random location withiin chromosome
        #         arandchr        = random.sample(chrL,1)[0] ## Draw chromosomes for required sample size
        #         chrstart,chrend = coordsD[arandchr]
        #         randstartL      = random.sample(range(int(chrstart), int(chrend)), 1)
        #         # print(randstart) ## It is a list 
        #         randstart       = randstartL[0]
        #         randend         = randstart+reqlen
        #         randstrand      = random.choice(strandL)
        #         if randend < chrend:
        #             # print("Valid region")
        #             iterL.append((arandchr,randstart,randend,randstrand))
        #         else:
        #             # print("-This random region %s-%s goes beyond chr end %s - skipping" % (randstart,randend,chrend))
        #             pass
            
        #     print("-iter-%s complete" % (aniter))
        #     featurecoords.append(iterL[:nsamples])
            # print("Length of feature coords for %s is %s" % (afeature,len(featurecoords)))

        ## All itnerations complete for this feature, appending results
        randcoordsD[afeature] = (featurecoords)
        # print("random dict snippet",randcoordsD[afeature])

    print("Random sample dictionary has coords for  %s entries" % (len(randcoordsD))) 

    print("Fn: sampler exit #########")
    return randcoordsD

def randompicker(aninput):
    '''
    Picks random coords for one itneration so that whole randoms ampling could be parallelized
    '''

    aniter,reqlen,strandL = aninput

    print("-iter-%s" % aniter)
    ### Draw random chromosomes - double the same size, just to keep some extra
    iterL       = [] ## Random coords for itneration 
    
    chrL = coordsD.keys()
    for i in range(nsamples*4):
        ### Now pick random location withiin chromosome
        arandchr        = random.sample(chrL,1)[0] ## Draw chromosomes for required sample size
        chrstart,chrend = coordsD[arandchr]
        randstartL      = random.sample(range(int(chrstart), int(chrend)), 1)
        # print(randstart) ## It is a list 
        randstart       = randstartL[0]
        randend         = randstart+reqlen
        randstrand      = random.choice(strandL)
        if randend < chrend:
            # print("Valid region")
            iterL.append((arandchr,randstart,randend,randstrand))
        else:
            # print("-This random region %s-%s goes beyond chr end %s - skipping" % (randstart,randend,chrend))
            pass
    
    print("-iter-%s complete" % (aniter))
    iterfinalL = iterL[:nsamples]

    return iterfinalL

def coordsparser(coordsFile):
    '''Takes the coords file and parses to give a dict with chr as key and start, end as values
    '''
    print("\nFn: coordsparser #########")
    fh_in = open(coordsFile,'r')
    fh_in.readline() ## Remove Header
    fileread = fh_in.readlines()

    coordsD = {} ## [name/chr],[start,stop]
    for i in fileread:
        ent = i.strip('\n').split('\t')
        achr,astart,aend    = ent
        # print(achr,astart,aend)
        coordsD[achr]       = (int(astart),int(aend))

    print("Coords dict with prepared with %s entries" % (len(coordsD)))
    # print(coordsD)
    print("Fn: coordsparser exit #########")
    
    return coordsD

def Coords2FASTA(con,coords,genomedb,flankType,buff):
    
    '''Get FASTA from our servers, based on start, end coords and strand'''

    ### Modifed to run as function 
    header              = 'N'                             ## Does file have header
    sep                 = '\t'                            ## Specify seprator used in spreadsheed or input file
    chrpos              = '1'                             ## Column for chromosome - excel format
    startpos            = '2'                             ## Column for start postion- excel format
    endpos              = '3'                             ## Column for end position - excel format
    SpecStrand          = 'Y'                             ## Y: If strand is available and sequence needs to be from specific strand OR  F: No strand information and you need forward strand B: Than you dont care about strand and want from both
    strandpos           = '4'                             ## Column for strand - excel format - should be 'w' and 'c'

    cur = con.cursor()
    
    file_out = coords.rpartition('.')[0]+'.fa'
    fh_out = open(file_out,'w')
    
    fh_in = open(coords,'r')
    if header == 'Y':
        fh_in.readline()
    
    for i in fh_in:
      
        coord = i.strip('\n').split(sep)
        # print ("\nThis is the entry:\n",coord)
        chr_id = str(coord[int(chrpos)-1]).strip().replace("chr","")

        ## Flanking sequnces dynamic or static #########
        if flankType == 0: ## Static
            buff = buff
        elif flankType == 1: ## Dynamic
            length = int(end)-int(start)+1
            buff = length*buffRatio
            print ('Length of sequence: %s | Length of buffer: %s' % (length,buff))
        else:
            print("Please input correct flank option - [D] Dynamic or [S] Static")
        
        ### Coordinates for 'w' and 'c' strands #######
        if SpecStrand == 'Y':
            strand = str(coord[int(strandpos)-1]).strip().translate(str.maketrans("+-","wc"))
            
            ## Start coulumn could have end co-ordinates in case of crick strand. Best is to determine the start and end
            ## before any operation

            alist   = [] ## To hold start end co-ordinates and pick min. value as start and max. as end
            start   = str(coord[int(startpos)-1]).strip() ##Buffer of 100bp or as specified
            end     = str(coord[int(endpos)-1]).strip()
            alist.append(start)
            alist.append(end)

            astart  = min(alist)
            aend    = (max(alist))

            start2  = int(astart)-buff
            if start2 < 0: ## Added to fix negative number query to my SQL
                start2 = 1
            else:
                pass

            length = (int(aend)-int(astart))+(buff*2)+1 ### extra 1 to include last position, buffer of 100 bp from start and end
            end2   = start2+length ## Not used for query but good to have 

        elif SpecStrand == "B" or SpecStrand == "F":
            alist   = [] ## To hold start end co-ordinates and pick min. value as start and max. as end
            start   = str(coord[int(startpos)-1]).strip() ##Buffer of 100bp or as specified
            end     = str(coord[int(endpos)-1]).strip()
            alist.append(start)
            alist.append(end)

            astart  = min(alist)
            aend    = (max(alist))
            
            start2  = int(astart)-buff ### It is assumned that start column is the start i.e. min value
            if start2 < 0: ## Added to fix negative number query to my SQL
                start2 = 1
            else:
                pass

            length = (int(aend)-int(astart))+(buff*2)+1 ### xtra 1 to include last position, buffer of 100 bp from start and end
            end2   = start2+length ## Not used for query but good to have 

        else:
            print("Please input correct option for specStrand")
            pass


        ## Check if buffer surpasses the chromosome length ###########
        cur.execute("select chr_id,length from %s.chromosome_master where chr_id= %s" % (genomedb,chr_id))
        temp = cur.fetchall()
        chr_len = temp[0][1]
        # print("Length of this chromosome:%s" % (chr_len))
        if int(end2) > int(chr_len):
            print("End cordinate %s surpasses chr length %s , defauting to max possible length" % (end2,chr_len))
            end2 = chr_len ## End of chromosome
        else:
            pass

        ### Fetch Seqeunces ########################################    
        cur = con.cursor()
        if SpecStrand == 'Y': ##Strand info available - Like if coordinates are for gene
            # print ('This is chr_id:%s and Strand: %s and Start:%s and End:%s | Length of sequence: %s bp\n' % (chr_id,strand,str(start2),int(end2),length))
            cur.execute("select substring(chromosome, %s, %s) from %s.chrom_sequence where chr_id = %s AND strand = '%s'" % (str(start2),length,genomedb,chr_id,strand))
            temp = cur.fetchall()
            #print (temp)
            #print (temp[1][0][::-1])
            if strand == 'w': ## Distinguish between strands so that you can reverce 'crick' strand to give correct orientation
                fh_out.write('>%s_%s_w_%s:%s:%s\n%s\n' % (cntsuffix,coord[0],chr_id,start2,end2,temp[0][0]))
            else:
                fh_out.write('>%s_%s_c_%s:%s:%s\n%s\n' % (cntsuffix,coord[0],chr_id,start2,end2,temp[0][0][::-1])) ### Just reverse to give correct orientation


        elif SpecStrand == 'F': ### No strand information forward strand required
            # print ('This is chr_id:%s and Start:%s and End:%s | Length of sequence: %s bp\n' % (chr_id,str(start2),int(end2),length))
            cur.execute("select substring(chromosome, %s, %s) from %s.chrom_sequence where chr_id = %s AND strand = 'w'" % (str(start2),length,genomedb,chr_id))####
            temp = cur.fetchall()
            #print (temp)### Both positive and negative strand reported
            fh_out.write('>%s_%s_w_%s:%s:%s\n%s\n' % (cntsuffix,coord[0],chr_id,start2,end2,temp[0][0]))

 
        elif SpecStrand == 'B': ### No strand information both strands were required
            # print ('This is chr_id:%s and Start:%s and End:%s | Length of sequence: %s bp\n' % (chr_id,str(start2),int(end2),length))
            cur.execute("select substring(chromosome, %s, %s) from %s.chrom_sequence where chr_id = %s" % (str(start2),length,genomedb,chr_id))####
            temp = cur.fetchall()
            #print (temp)### Both positive and negative strand reported
            fh_out.write('>%s_%s_w_%s:%s:%s\n%s\n' % (cntsuffix,coord[0],chr_id,start2,end2,temp[0][0]))
            fh_out.write('>%s_%s_c_%s:%s:%s\n%s\n' % (cntsuffix,coord[0],chr_id,start2,end2,temp[1][0][::-1])) ### Reversed to give correct orientation

        else:
            print("Choose correct option for 'SpecStrand' parameter")
            sys.exit()

    fh_out.close()

    return file_out

def ConnectToDB(server):
    
    ##infile values are '0' when you dont want to pulaod data from local file and '1' when you wish to upload data by local file
    ##EX:con=sql.connect(host= server, user='kakrana', passwd='livetheday', local_infile = infile)
    ##Now later in script you can
    ##cur.execute("LOAD DATA LOCAL INFILE './scoring_input_extend2' INTO TABLE kakrana_data.mir_page_results FIELDS TERMINATED BY ','")
    
    print ('\nTrying to connect to mySQL server on %s' % (server))
    # Try to connect to the database
    try:
        con=sql.connect(host= server, user='kakrana', passwd='livetheday')###local_infile = 1 not supported yet so a table has to be updated on row basis
        print ('Connection Established\n')

    # If we cannot connect to the database, send an error to the user and exit the program.
    except sql.Error:
        print ("Error %d: %s" % (sql.Error.args[0],sql.Error.args[1]))
        sys.exit(1)
        
    return con

def randcoordsWriter(afeature,aniterL):
    '''
    writes random coords - for test with just one feature
    '''

    print("\nFn: randcoordsWriter #########")
    ## Write coords to fetch fasta
    tempcoords = "temp.coords.txt"
    fh_out = open(tempcoords,'w')

    for arand in aniterL:
        # print(arand)
        arandchr,randstart,randend,randstrand = arand
        fh_out.write("%s\t%s\t%s\t%s\n" % (arandchr,randstart,randend,randstrand))
    
    fh_out.close
    print("Fn: randcoordsWriter exit #########")

    return tempcoords

def fastaReader(fastaFile):
    
    '''Cleans FASTA file - multi-line fasta to single line, header clean, empty lines removal'''

    print("\nFUNCTION - fastaReader")
    ## Read seqeunce file
    print ('-Reading "%s" FASTA file' % (fastaFile))
    fh_in       = open(fastaFile, 'r')
    fasta       = fh_in.read()
    fasta_splt  = fasta.split('>')
    acount      = 0 ## count the number of entries
    empty_count = 0

    fastaList = [] ## Stores name and seq for fastFile
    fastaD    = {}

    acount +=1
    for i in fasta_splt[1:]:
        acount  +=1
        ent     = i.split('\n')
        name    = ent[0].split()[0].strip()
        seq     = ''.join(x.strip() for x in ent[1:]) ## Sequence in multiple lines
        alen    = len(seq)
        fastaList.append((name,seq,alen))
        fastaD[name] = (seq,alen)

    print("-Total entries in phased fastaFile:%s" % (str(acount)))
    print("-fastaList generated with %s entries\n" % (str(len(fastaList))))
    # print("-Length for %s:%s" % (name,alen))

    return fastaList,fastaD

def writer2(sigclustD,pvalD):
    '''
    writes results - comaptaible with as many as species
    '''
    outfile = "cd-hit.parsed.pvals.%s.txt" % datetime.datetime.now().strftime("%m_%d_%H_%M")
    fh_out = open(outfile,'w')

    for akey in sigclustD.keys():
        ares    = sigclustD[akey]
        # print("Results",ares)
        lenL    = [str(x[1]) for x in ares]
        seqL    = [str(y[3]) for y in ares]
        percL   = [str(z[4]) for z in ares]
        combres = ['\t'.join(pair) for pair in zip(seqL,percL,lenL)]
        pval,testname    = pvalD[akey]
        # print(lenL,seqL,percL)
        fh_out.write("%s\t%s\t%s\n" % (str(akey),pval,"\t".join(combres)))

    fh_out.close()
    return outfile

def PPResults(module,alist):
    npool = Pool(int(nproc))    
    res = npool.map_async(module, alist)
    if(res.get() == []):
        print("YEP!")
    results = (res.get())
    npool.close()           ### Added by Reza to close hanging 
    return results

def main():
    clustD      = parseclust(clustFile)
    sigclustD   = sigclust(clustD)
    writer(sigclustD)

    if mode == 1:
        ## Random sampling and p-value computations
        pvalcompute(sigclustD,coordsFile)
    else:
        pass

    pass

if __name__ == '__main__':
    if nproc == 'Y':
        nproc = int(multiprocessing.cpu_count()*0.50)
    else:
        nproc == int(nproc)
    main()


## v01 - 7-Apr-16

##v06 -> v07
## Improved results writing for multiple species